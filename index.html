<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#000000">
  <title>Beatstar Clone</title>
  <link rel="manifest" href="manifest.json">
  
  <style>
    * {
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      user-select: none;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      height: 100%;
      overflow: hidden;
      overscroll-behavior: none;
      position: fixed;
      width: 100%;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    
    #root {
      width: 100%;
      height: 100%;
      overflow: auto;
    }

    @keyframes gradientShift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .game-bg-purple {
      background: linear-gradient(45deg, #4a148c, #6a1b9a, #8e24aa, #ab47bc);
      background-size: 400% 400%;
      animation: gradientShift 8s ease infinite;
    }

    .game-bg-orange {
      background: linear-gradient(45deg, #e65100, #f57c00, #fb8c00, #ffa726);
      background-size: 400% 400%;
      animation: gradientShift 8s ease infinite;
    }

    .game-bg-green {
      background: linear-gradient(45deg, #1b5e20, #2e7d32, #388e3c, #4caf50);
      background-size: 400% 400%;
      animation: gradientShift 8s ease infinite;
    }

    @keyframes laneFlash {
      0% { background-color: rgba(255, 255, 255, 0.4); }
      100% { background-color: transparent; }
    }

    .lane-flash {
      animation: laneFlash 0.2s ease-out;
    }

    @keyframes judgmentPop {
      0% { transform: scale(0) translateY(-50%); opacity: 0; }
      50% { transform: scale(1.2) translateY(-50%); opacity: 1; }
      100% { transform: scale(1) translateY(-50%); opacity: 0; }
    }

    .judgment-text {
      animation: judgmentPop 0.6s ease-out;
    }

    /* Loading spinner */
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .spinner {
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid white;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
    }
  </style>
  
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>
  
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    
    // Icons
    const Plus = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" /></svg>;
    const Star = ({className = "w-5 h-5"}) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z" /></svg>;
    const Lock = ({className = "w-4 h-4"}) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" /></svg>;
    const Music = ({className = "w-8 h-8"}) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3" /></svg>;
    const Award = ({className = "w-5 h-5"}) => <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4M7.835 4.697a3.42 3.42 0 001.946-.806 3.42 3.42 0 014.438 0 3.42 3.42 0 001.946.806 3.42 3.42 0 013.138 3.138 3.42 3.42 0 00.806 1.946 3.42 3.42 0 010 4.438 3.42 3.42 0 00-.806 1.946 3.42 3.42 0 01-3.138 3.138 3.42 3.42 0 00-1.946.806 3.42 3.42 0 01-4.438 0 3.42 3.42 0 00-1.946-.806 3.42 3.42 0 01-3.138-3.138 3.42 3.42 0 00-.806-1.946 3.42 3.42 0 010-4.438 3.42 3.42 0 00.806-1.946 3.42 3.42 0 013.138-3.138z" /></svg>;

    // GAME SETTINGS
    const LANES = 3;
    const HIT_PANEL_POSITION = 0.82; // Hit panel starts here
    const HIT_PANEL_HEIGHT = 0.10; // Panel height (10% of screen)
    const HIT_LINE_POSITION = 0.87; // Center of hit panel
    const NOTE_SPEED = 0.00055; // Slower for better sync
    const NOTE_HEIGHT = 85;
    const TIMING_WINDOWS = { 
      perfect: 60,
      great: 100, 
      good: 150, 
      miss: 200 
    };
    const NOTE_TYPES = { TAP: 'tap', HOLD: 'hold', SWIPE_LEFT: 'swipe-left', SWIPE_RIGHT: 'swipe-right', SWIPE_UP: 'swipe-up' };

    const INITIAL_PLAYER = {
      id: 'player1', name: 'Player', currency: 100, totalStars: 0,
      unlockedSongs: [], // Will be populated from songs folder
      completedChallenges: [], scores: {}, wishlist: [], unlockedGiftBoxes: []
    };

    // This will be populated from songs folder
    const loadSongsFromFolder = async () => {
      const songFiles = [
        { filename: 'no-me-pidas-perdon.mp3', jsonFile: 'no-me-pidas-perdon.json' },
        { filename: 'levels.mp3', jsonFile: 'levels.json' }
      ];

      const songs = [];
      
      for (const file of songFiles) {
        try {
          const response = await fetch(`./songs/${file.jsonFile}`);
          if (response.ok) {
            const metadata = await response.json();
            songs.push({
              id: metadata.id || file.filename.replace('.mp3', ''),
              title: metadata.title,
              artist: metadata.artist,
              genre: metadata.genre,
              bpm: metadata.bpm,
              duration: metadata.duration,
              difficulty: metadata.difficulty,
              unlockTier: metadata.unlockTier || 0,
              requiredStars: metadata.requiredStars || 0,
              audioUrl: `./songs/${file.filename}`
            });
          }
        } catch (e) {
          console.error(`Failed to load ${file.jsonFile}:`, e);
        }
      }

      // If no songs loaded, return defaults
      if (songs.length === 0) {
        return [
          { id: 'song-1', title: 'Starter Beat', artist: 'Tutorial', genre: 'Electronic', unlockTier: 0, bpm: 120, duration: 90, difficulty: { easy: 1, normal: 3, hard: 5 }, audioUrl: null },
          { id: 'song-2', title: 'Rhythm Flow', artist: 'Beginner', genre: 'Pop', unlockTier: 0, bpm: 110, duration: 90, difficulty: { easy: 2, normal: 4, hard: 6 }, audioUrl: null },
          { id: 'song-3', title: 'Beat Drop', artist: 'Starter', genre: 'Electronic', unlockTier: 0, bpm: 128, duration: 90, difficulty: { easy: 1, normal: 3, hard: 5 }, audioUrl: null }
        ];
      }

      return songs;
    };

    // Generate beatmap synced to actual beats
    const generateBeatmap = (bpm, duration, difficulty) => {
      const notes = [];
      const beatInterval = (60 / bpm) * 1000; // ms per beat
      const noteDensity = { easy: 0.5, normal: 0.75, hard: 1.0 }[difficulty] || 0.75;
      
      let time = 3000; // Start after 3 seconds
      const endTime = duration * 1000 - 2000;
      let lastLane = -1;

      while (time < endTime) {
        // Place notes on beats or half-beats depending on difficulty
        const onBeat = Math.round(time / beatInterval) * beatInterval;
        time = onBeat;

        // Choose lane (avoid same lane twice in a row)
        let lane = Math.floor(Math.random() * LANES);
        if (lane === lastLane && LANES > 1) {
          lane = (lane + 1) % LANES;
        }
        lastLane = lane;

        const noteTypeRoll = Math.random();
        let noteType = NOTE_TYPES.TAP;
        
        if (difficulty === 'hard') {
          if (noteTypeRoll < 0.10) noteType = NOTE_TYPES.HOLD;
          else if (noteTypeRoll < 0.20) noteType = NOTE_TYPES.SWIPE_LEFT;
          else if (noteTypeRoll < 0.30) noteType = NOTE_TYPES.SWIPE_RIGHT;
          else if (noteTypeRoll < 0.40) noteType = NOTE_TYPES.SWIPE_UP;
        } else if (difficulty === 'normal') {
          if (noteTypeRoll < 0.08) noteType = NOTE_TYPES.HOLD;
          else if (noteTypeRoll < 0.15) noteType = NOTE_TYPES.SWIPE_UP;
        }

        notes.push({ 
          id: `note-${time}-${lane}`, 
          lane, 
          time, 
          type: noteType, 
          duration: noteType === NOTE_TYPES.HOLD ? beatInterval * 2 : 0 
        });
        
        time += beatInterval / noteDensity;
      }
      return notes;
    };

    const calculateStars = (accuracy) => {
      if (accuracy >= 98) return 5;
      if (accuracy >= 95) return 4;
      if (accuracy >= 90) return 3;
      if (accuracy >= 80) return 2;
      if (accuracy >= 60) return 1;
      return 0;
    };

    const calculateCurrency = (stars, difficulty) => {
      const baseReward = { easy: 10, normal: 20, hard: 30 }[difficulty] || 10;
      return baseReward * stars;
    };

    function BeatstarClone() {
      const [currentScreen, setCurrentScreen] = useState('loading');
      const [player, setPlayer] = useState(() => {
        const saved = localStorage.getItem('beatstar-player');
        return saved ? JSON.parse(saved) : INITIAL_PLAYER;
      });
      const [songs, setSongs] = useState([]);
      const [selectedSong, setSelectedSong] = useState(null);
      const [selectedDifficulty, setSelectedDifficulty] = useState('normal');
      const [showUnlockChoice, setShowUnlockChoice] = useState(false);
      const [unlockOptions, setUnlockOptions] = useState([]);

      useEffect(() => {
        // Load songs on mount
        loadSongsFromFolder().then(loadedSongs => {
          setSongs(loadedSongs);
          // Unlock all songs by default for now
          if (player.unlockedSongs.length === 0) {
            setPlayer(prev => ({
              ...prev,
              unlockedSongs: loadedSongs.map(s => s.id)
            }));
          }
          setCurrentScreen('home');
        });
      }, []);

      useEffect(() => { localStorage.setItem('beatstar-player', JSON.stringify(player)); }, [player]);

      const isSongUnlocked = (song) => player.unlockedSongs.includes(song.id);
      const startGame = (song, difficulty) => { setSelectedSong(song); setSelectedDifficulty(difficulty); setCurrentScreen('game'); };

      const endGame = (score, accuracy, perfect, great, good, miss) => {
        const stars = calculateStars(accuracy);
        const currencyEarned = calculateCurrency(stars, selectedDifficulty);
        const scoreKey = `${selectedSong.id}-${selectedDifficulty}`;
        const previousBest = player.scores[scoreKey];
        const isNewBest = !previousBest || score > previousBest.score;

        setPlayer(prev => {
          const newScores = { ...prev.scores };
          if (isNewBest) newScores[scoreKey] = { score, stars, accuracy, perfect, great, good, miss };
          const newTotalStars = Object.values(newScores).reduce((sum, s) => sum + s.stars, 0);
          return { ...prev, scores: newScores, totalStars: newTotalStars, currency: prev.currency + currencyEarned };
        });
        setCurrentScreen('home');
      };

      if (currentScreen === 'loading') {
        return (
          <div className="min-h-screen bg-gradient-to-br from-purple-900 via-black to-blue-900 flex items-center justify-center">
            <div className="text-center text-white">
              <div className="spinner mx-auto mb-4"></div>
              <p>Loading songs...</p>
            </div>
          </div>
        );
      }

      if (currentScreen === 'game' && selectedSong) return <GameScreen song={selectedSong} difficulty={selectedDifficulty} onEnd={endGame} onBack={() => setCurrentScreen('home')} />;

      return (
        <div className="min-h-screen bg-gradient-to-br from-purple-900 via-black to-blue-900 text-white">
          <div className="bg-black/40 backdrop-blur-sm border-b border-purple-500/30 p-4">
            <div className="flex justify-between items-center max-w-6xl mx-auto">
              <div>
                <h1 className="text-3xl font-black tracking-tight text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-400">BEATSTAR</h1>
                <p className="text-sm text-purple-300">{player.name}</p>
              </div>
              <div className="flex gap-4 items-center">
                <div className="flex items-center gap-2 bg-yellow-500/20 px-4 py-2 rounded-full border border-yellow-400/30">
                  <Award /><span className="font-bold text-yellow-300">{player.currency}</span>
                </div>
                <div className="flex items-center gap-2 bg-purple-500/20 px-4 py-2 rounded-full border border-purple-400/30">
                  <Star /><span className="font-bold text-purple-300">{player.totalStars}</span>
                </div>
              </div>
            </div>
          </div>

          <div className="p-6 max-w-6xl mx-auto">
            <h2 className="text-2xl font-black text-purple-300 mb-6">Your Songs</h2>

            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {songs.map(song => {
                const unlocked = isSongUnlocked(song);
                return (
                  <div key={song.id} className={`relative bg-gradient-to-br from-purple-900/50 to-blue-900/50 rounded-xl p-5 border-2 ${unlocked ? 'border-purple-500/50' : 'border-gray-700/50 opacity-60'}`}>
                    {!unlocked && <div className="absolute top-3 right-3 bg-red-500/80 p-2 rounded-full"><Lock /></div>}
                    <div className="flex items-center gap-3 mb-3">
                      <div className="w-16 h-16 rounded-lg bg-gradient-to-br from-pink-500 to-purple-600 flex items-center justify-center"><Music /></div>
                      <div className="flex-1">
                        <h3 className="font-bold text-lg">{unlocked ? song.title : '???'}</h3>
                        <p className="text-sm text-purple-300">{unlocked ? song.artist : 'Locked'}</p>
                      </div>
                    </div>
                    {unlocked && (
                      <>
                        <div className="flex gap-2 mb-3">
                          <span className="text-xs px-2 py-1 bg-purple-500/30 rounded">{song.genre}</span>
                          <span className="text-xs px-2 py-1 bg-blue-500/30 rounded">{song.bpm} BPM</span>
                        </div>
                        <div className="grid grid-cols-3 gap-2">
                          {['easy', 'normal', 'hard'].map(diff => {
                            const scoreKey = `${song.id}-${diff}`;
                            const score = player.scores[scoreKey];
                            return (
                              <button key={diff} onClick={() => startGame(song, diff)} className="bg-black/40 p-2 rounded-lg hover:bg-black/60 text-left">
                                <div className="text-xs font-bold uppercase text-purple-300">{diff}</div>
                                <div className="text-xs text-gray-400">Lvl {song.difficulty[diff]}</div>
                                {score && <div className="flex items-center gap-1 mt-1">{[...Array(score.stars)].map((_, i) => <Star key={i} className="w-3 h-3 fill-yellow-400 text-yellow-400" />)}</div>}
                              </button>
                            );
                          })}
                        </div>
                      </>
                    )}
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      );
    }

    function GameScreen({ song, difficulty, onEnd, onBack }) {
      const [gameState, setGameState] = useState('ready');
      const [score, setScore] = useState(0);
      const [combo, setCombo] = useState(0);
      const [maxCombo, setMaxCombo] = useState(0);
      const [judgments, setJudgments] = useState({ perfect: 0, great: 0, good: 0, miss: 0 });
      const [notes, setNotes] = useState([]);
      const [currentTime, setCurrentTime] = useState(0);
      const [beatmap, setBeatmap] = useState(null);
      const [touchStart, setTouchStart] = useState({});
      const [laneFlashes, setLaneFlashes] = useState([false, false, false]);
      const [judgmentDisplay, setJudgmentDisplay] = useState(null);
      const gameLoopRef = useRef(null);
      const startTimeRef = useRef(null);
      const audioRef = useRef(null);

      useEffect(() => {
        const map = generateBeatmap(song.bpm, song.duration, difficulty);
        setBeatmap(map);
        setNotes(map.map(n => ({ ...n, hit: false, missed: false })));
      }, [song, difficulty]);

      const startGame = () => {
        setGameState('playing');
        startTimeRef.current = Date.now();
        if (song.audioUrl) { 
          audioRef.current = new Audio(song.audioUrl); 
          audioRef.current.play().catch(e => console.log('Audio play failed:', e)); 
        }
        gameLoopRef.current = setInterval(() => {
          const elapsed = Date.now() - startTimeRef.current;
          setCurrentTime(elapsed);
          setNotes(prev => prev.map(note => {
            if (!note.hit && !note.missed && elapsed > note.time + TIMING_WINDOWS.miss) {
              setCombo(0);
              setJudgments(j => ({ ...j, miss: j.miss + 1 }));
              showJudgment('MISS', 'text-red-500');
              return { ...note, missed: true };
            }
            return note;
          }));
          if (elapsed > song.duration * 1000) endGameNow();
        }, 16);
      };

      const endGameNow = () => {
        clearInterval(gameLoopRef.current);
        if (audioRef.current) { audioRef.current.pause(); audioRef.current = null; }
        setGameState('finished');
        const totalNotes = beatmap.length;
        const hitNotes = judgments.perfect + judgments.great + judgments.good;
        const accuracy = totalNotes > 0 ? (hitNotes / totalNotes) * 100 : 0;
        setTimeout(() => { onEnd(score, accuracy, judgments.perfect, judgments.great, judgments.good, judgments.miss); }, 2000);
      };

      const flashLane = (lane) => {
        setLaneFlashes(prev => { const n = [...prev]; n[lane] = true; return n; });
        setTimeout(() => setLaneFlashes(prev => { const n = [...prev]; n[lane] = false; return n; }), 200);
      };

      const showJudgment = (text, color) => {
        setJudgmentDisplay({ text, color });
        setTimeout(() => setJudgmentDisplay(null), 600);
      };

      const handleTouchStart = (e, lane) => {
        e.preventDefault();
        const touch = e.touches[0];
        setTouchStart({ x: touch.clientX, y: touch.clientY, lane, time: Date.now() });
        checkHit(lane, null);
      };

      const handleTouchEnd = (e, lane) => {
        e.preventDefault();
        if (!touchStart.lane) return;
        const touch = e.changedTouches[0];
        const dx = touch.clientX - touchStart.x;
        const dy = touch.clientY - touchStart.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance > 50) {
          const angle = Math.atan2(dy, dx) * (180 / Math.PI);
          let swipeType = null;
          if (angle > -45 && angle < 45) swipeType = NOTE_TYPES.SWIPE_RIGHT;
          else if (angle < -45 && angle > -135) swipeType = NOTE_TYPES.SWIPE_UP;
          else swipeType = NOTE_TYPES.SWIPE_LEFT;
          if (swipeType) checkHit(lane, swipeType);
        }
        setTouchStart({});
      };

      const checkHit = (lane, swipeType) => {
        const hitTime = currentTime;
        let bestNote = null;
        let bestTiming = Infinity;
        
        notes.forEach(note => {
          if (note.lane === lane && !note.hit && !note.missed) {
            const timing = Math.abs(note.time - hitTime);
            if (timing < TIMING_WINDOWS.miss && timing < bestTiming) {
              // Check note type matches
              if (swipeType && note.type !== swipeType && note.type !== NOTE_TYPES.TAP) return;
              if (!swipeType && note.type !== NOTE_TYPES.TAP && note.type !== NOTE_TYPES.HOLD) return;
              bestNote = note; 
              bestTiming = timing;
            }
          }
        });

        if (bestNote) {
          let judgment = 'miss', points = 0, judgmentText = 'MISS', judgmentColor = 'text-red-500';
          
          if (bestTiming < TIMING_WINDOWS.perfect) {
            judgment = 'perfect';
            points = 100;
            judgmentText = 'PERFECT+';
            judgmentColor = 'text-cyan-400';
          } else if (bestTiming < TIMING_WINDOWS.great) {
            judgment = 'great';
            points = 75;
            judgmentText = 'GREAT';
            judgmentColor = 'text-green-400';
          } else if (bestTiming < TIMING_WINDOWS.good) {
            judgment = 'good';
            points = 50;
            judgmentText = 'GOOD';
            judgmentColor = 'text-yellow-400';
          }

          if (judgment !== 'miss') {
            setNotes(prev => prev.map(n => n.id === bestNote.id ? { ...n, hit: true } : n));
            setScore(s => s + points * (combo + 1));
            setCombo(c => {
              const newCombo = c + 1;
              setMaxCombo(max => Math.max(max, newCombo));
              return newCombo;
            });
            setJudgments(j => ({ ...j, [judgment]: j[judgment] + 1 }));
            flashLane(lane);
            showJudgment(judgmentText, judgmentColor);
          } else {
            setCombo(0);
            showJudgment(judgmentText, judgmentColor);
          }
        }
      };

      if (gameState === 'ready') {
        const bgColor = difficulty === 'easy' ? 'game-bg-green' : difficulty === 'normal' ? 'game-bg-orange' : 'game-bg-purple';
        return (
          <div className={`min-h-screen ${bgColor} flex items-center justify-center text-white`}>
            <div className="text-center">
              <h1 className="text-4xl font-black mb-4 drop-shadow-lg">{song.title}</h1>
              <p className="text-xl mb-2 opacity-90">{song.artist}</p>
              <p className="text-lg opacity-75 mb-8">{difficulty.toUpperCase()} - Level {song.difficulty[difficulty]}</p>
              <button onClick={startGame} className="bg-white text-black px-12 py-4 rounded-full text-2xl font-black hover:scale-105 transition-transform shadow-2xl">
                START
              </button>
              <button onClick={onBack} className="block mx-auto mt-4 opacity-75 hover:opacity-100 transition-opacity">
                ← Back
              </button>
            </div>
          </div>
        );
      }

      if (gameState === 'finished') {
        const totalNotes = beatmap.length;
        const hitNotes = judgments.perfect + judgments.great + judgments.good;
        const accuracy = totalNotes > 0 ? ((hitNotes / totalNotes) * 100).toFixed(1) : 0;
        const stars = calculateStars(accuracy);
        const bgColor = difficulty === 'easy' ? 'game-bg-green' : difficulty === 'normal' ? 'game-bg-orange' : 'game-bg-purple';
        
        return (
          <div className={`min-h-screen ${bgColor} flex items-center justify-center text-white p-6`}>
            <div className="text-center max-w-md">
              <div className="relative w-48 h-48 mx-auto mb-8">
                <svg className="w-full h-full transform -rotate-90">
                  <circle cx="96" cy="96" r="88" stroke="rgba(255,255,255,0.2)" strokeWidth="8" fill="none" />
                  <circle cx="96" cy="96" r="88" stroke="white" strokeWidth="8" fill="none" 
                    strokeDasharray={`${(accuracy / 100) * 553} 553`}
                    strokeLinecap="round" />
                </svg>
                <div className="absolute inset-0 flex flex-col items-center justify-center">
                  <div className="text-sm opacity-75">FINAL STAGE</div>
                  <div className="text-4xl font-black">{score.toLocaleString()}</div>
                  <div className="text-sm opacity-75">:{stars}</div>
                </div>
              </div>

              <div className="flex justify-center gap-2 mb-6">
                {[...Array(5)].map((_, i) => (
                  <Star key={i} className={`w-10 h-10 ${i < stars ? 'fill-yellow-400 text-yellow-400' : 'fill-none text-white opacity-30'}`} />
                ))}
              </div>

              <div className="bg-black/40 rounded-2xl p-6 backdrop-blur-sm">
                <div className="text-xl mb-4">Accuracy: {accuracy}%</div>
                <div className="grid grid-cols-4 gap-3 text-sm">
                  <div className="bg-cyan-500/20 rounded-lg p-3">
                    <div className="text-2xl font-bold text-cyan-400">{judgments.perfect}</div>
                    <div className="text-xs opacity-75">PERFECT</div>
                  </div>
                  <div className="bg-green-500/20 rounded-lg p-3">
                    <div className="text-2xl font-bold text-green-400">{judgments.great}</div>
                    <div className="text-xs opacity-75">GREAT</div>
                  </div>
                  <div className="bg-yellow-500/20 rounded-lg p-3">
                    <div className="text-2xl font-bold text-yellow-400">{judgments.good}</div>
                    <div className="text-xs opacity-75">GOOD</div>
                  </div>
                  <div className="bg-red-500/20 rounded-lg p-3">
                    <div className="text-2xl font-bold text-red-400">{judgments.miss}</div>
                    <div className="text-xs opacity-75">MISS</div>
                  </div>
                </div>
                <div className="mt-4 text-sm opacity-75">Max Combo: {maxCombo}</div>
              </div>
            </div>
          </div>
        );
      }

      // PLAYING STATE
      const visibleNotes = notes.filter(note => {
        const position = (currentTime - note.time) * NOTE_SPEED + HIT_LINE_POSITION;
        return position >= -0.1 && position <= 1.1 && !note.hit && !note.missed;
      });

      const bgColor = difficulty === 'easy' ? 'game-bg-green' : difficulty === 'normal' ? 'game-bg-orange' : 'game-bg-purple';
      const progress = (currentTime / (song.duration * 1000)) * 100;

      return (
        <div className={`relative w-full h-screen ${bgColor} overflow-hidden touch-none`}>
          {/* Top Score Circle */}
          <div className="absolute top-4 left-0 right-0 z-30 flex justify-center">
            <div className="relative w-32 h-32">
              <svg className="w-full h-full transform -rotate-90">
                <circle cx="64" cy="64" r="58" stroke="rgba(255,255,255,0.3)" strokeWidth="4" fill="rgba(0,0,0,0.6)" />
                <circle cx="64" cy="64" r="58" stroke="white" strokeWidth="4" fill="none" 
                  strokeDasharray={`${(progress / 100) * 365} 365`}
                  strokeLinecap="round" />
              </svg>
              <div className="absolute inset-0 flex flex-col items-center justify-center text-white">
                <div className="text-xs opacity-75">STAGE {difficulty === 'easy' ? '1' : difficulty === 'normal' ? '2' : '3'}</div>
                <div className="text-2xl font-black">{score.toLocaleString()}</div>
                <div className="text-xs opacity-75">×{combo}</div>
              </div>
            </div>
          </div>

          {/* Judgment Display */}
          {judgmentDisplay && (
            <div className="absolute top-1/3 left-0 right-0 z-40 flex justify-center pointer-events-none">
              <div className={`judgment-text text-5xl font-black ${judgmentDisplay.color} drop-shadow-2xl`}>
                {judgmentDisplay.text}
              </div>
            </div>
          )}

          {/* Game Area */}
          <div className="absolute inset-0 flex items-end" style={{ paddingBottom: '5%' }}>
            <div className="w-full h-full flex relative">
              {/* Hit Panel - The white/translucent area */}
              <div 
                className="absolute left-0 right-0 z-10 pointer-events-none bg-gradient-to-b from-white/5 via-white/20 to-white/5 border-y-2 border-white/40"
                style={{ 
                  top: `${HIT_PANEL_POSITION * 100}%`,
                  height: `${HIT_PANEL_HEIGHT * 100}%`,
                  boxShadow: 'inset 0 2px 20px rgba(255,255,255,0.3), 0 0 30px rgba(255,255,255,0.2)'
                }}
              >
                {/* "PERFECT" text like in Beatstar */}
                <div className="absolute bottom-2 left-0 right-0 text-center text-white/20 text-xs font-bold tracking-widest">
                  P E R F E C T
                </div>
              </div>

              {/* Lane borders */}
              <div className="absolute inset-0 flex pointer-events-none z-5">
                {[...Array(LANES)].map((_, i) => (
                  <div key={i} className="flex-1 relative">
                    {i === 0 && <div className="absolute left-0 top-0 bottom-0 w-1 bg-gradient-to-b from-transparent via-white/50 to-transparent" />}
                    {i === LANES - 1 && <div className="absolute right-0 top-0 bottom-0 w-1 bg-gradient-to-b from-transparent via-white/50 to-transparent" />}
                    {i < LANES - 1 && <div className="absolute right-0 top-0 bottom-0 w-0.5 bg-white/20" />}
                  </div>
                ))}
              </div>

              {/* Interactive Lanes */}
              {[...Array(LANES)].map((_, lane) => (
                <div
                  key={lane}
                  className={`flex-1 relative z-20 ${laneFlashes[lane] ? 'lane-flash' : ''}`}
                  onTouchStart={(e) => handleTouchStart(e, lane)}
                  onTouchEnd={(e) => handleTouchEnd(e, lane)}
                  onClick={() => checkHit(lane, null)}
                >
                  {/* Notes with proper visuals */}
                  {visibleNotes.filter(note => note.lane === lane).map(note => {
                    const position = ((currentTime - note.time) * NOTE_SPEED + HIT_LINE_POSITION) * 100;
                    
                    return (
                      <div
                        key={note.id}
                        className="absolute left-2 right-2 flex items-center justify-center pointer-events-none"
                        style={{ 
                          top: `${position}%`, 
                          transform: 'translateY(-50%)',
                          height: `${NOTE_HEIGHT}px`
                        }}
                      >
                        {/* TAP - solid dark tile */}
                        {note.type === NOTE_TYPES.TAP && (
                          <div className="w-full h-full rounded-xl bg-gradient-to-b from-gray-700 via-gray-900 to-black border-2 border-white/60 shadow-2xl flex items-center justify-center"
                            style={{ boxShadow: '0 4px 25px rgba(0,0,0,0.7), inset 0 2px 15px rgba(255,255,255,0.2)' }}>
                            {/* Horizontal line indicator */}
                            <div className="w-3/4 h-1 bg-white/80 rounded-full" />
                          </div>
                        )}

                        {/* HOLD - yellow with horizontal lines */}
                        {note.type === NOTE_TYPES.HOLD && (
                          <div className="w-full rounded-xl bg-gradient-to-b from-yellow-500 via-yellow-600 to-orange-700 border-2 border-yellow-300 shadow-2xl flex flex-col items-center justify-around py-2" 
                            style={{ height: `${NOTE_HEIGHT * 2.5}px`, boxShadow: '0 4px 25px rgba(251,191,36,0.6)' }}>
                            <div className="w-3/4 h-1 bg-white/90 rounded-full" />
                            <div className="w-3/4 h-1 bg-white/90 rounded-full" />
                            <div className="w-3/4 h-1 bg-white/90 rounded-full" />
                            <div className="w-3/4 h-1 bg-white/90 rounded-full" />
                          </div>
                        )}

                        {/* SWIPE UP - dark with arrow */}
                        {note.type === NOTE_TYPES.SWIPE_UP && (
                          <div className="w-full h-full rounded-xl bg-gradient-to-b from-gray-700 via-gray-900 to-black border-2 border-cyan-300 flex items-center justify-center shadow-2xl"
                            style={{ boxShadow: '0 4px 25px rgba(34,211,238,0.6), inset 0 2px 15px rgba(34,211,238,0.3)' }}>
                            <svg className="w-16 h-16 text-white" fill="currentColor" viewBox="0 0 24 24">
                              <path d="M12 4l-8 8h5v8h6v-8h5z" />
                            </svg>
                          </div>
                        )}

                        {/* SWIPE LEFT */}
                        {note.type === NOTE_TYPES.SWIPE_LEFT && (
                          <div className="w-full h-full rounded-xl bg-gradient-to-b from-gray-700 via-gray-900 to-black border-2 border-red-300 flex items-center justify-center shadow-2xl"
                            style={{ boxShadow: '0 4px 25px rgba(248,113,113,0.6), inset 0 2px 15px rgba(248,113,113,0.3)' }}>
                            <svg className="w-16 h-16 text-white" fill="currentColor" viewBox="0 0 24 24">
                              <path d="M20 12l-8-8v5H4v6h8v5z" transform="rotate(180 12 12)" />
                            </svg>
                          </div>
                        )}

                        {/* SWIPE RIGHT */}
                        {note.type === NOTE_TYPES.SWIPE_RIGHT && (
                          <div className="w-full h-full rounded-xl bg-gradient-to-b from-gray-700 via-gray-900 to-black border-2 border-purple-300 flex items-center justify-center shadow-2xl"
                            style={{ boxShadow: '0 4px 25px rgba(192,132,252,0.6), inset 0 2px 15px rgba(192,132,252,0.3)' }}>
                            <svg className="w-16 h-16 text-white" fill="currentColor" viewBox="0 0 24 24">
                              <path d="M20 12l-8-8v5H4v6h8v5z" />
                            </svg>
                          </div>
                        )}
                      </div>
                    );
                  })}
                </div>
              ))}
            </div>
          </div>

          {/* Exit button */}
          <button 
            onClick={onBack}
            className="absolute top-4 right-4 z-30 bg-black/60 text-white px-4 py-2 rounded-lg font-bold backdrop-blur-sm hover:bg-black/80 transition-all"
          >
            Exit
          </button>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<BeatstarClone />);
  </script>
</body>
</html>
